// ********RoostGPT********
// Test generated by RoostGPT for test cpp using AI Type Claude AI and AI Model claude-3-opus-20240229



// ********RoostGPT********
#include <gtest/gtest.h>
#include <cstdio>
#include <cstring>

// Assuming the modifData function is defined in a separate header file
extern int modifData(char mode, int *money, int *lvl, int *exp, int *inventory, int inventory_S);

// Test fixture class
class ModifDataTest : public ::testing::Test {
protected:
    int money;
    int lvl;
    int exp;
    int inventory[5];
    int inventory_S;

    void SetUp() override {
        money = 100;
        lvl = 5;
        exp = 1000;
        inventory_S = 5;
        for (int i = 0; i < inventory_S; i++) {
            inventory[i] = i + 1;
        }
    }

    void TearDown() override {
        std::remove("player.esav");
    }
};

// Test case for saving data
TEST_F(ModifDataTest, SaveData) {
    EXPECT_EQ(modifData('s', &money, &lvl, &exp, inventory, inventory_S), 0);
    EXPECT_TRUE(std::ifstream("player.esav").good());
}

// Test case for loading data
TEST_F(ModifDataTest, LoadData) {
    // Save data first
    modifData('s', &money, &lvl, &exp, inventory, inventory_S);

    // Modify the variables
    money = 200;
    lvl = 10;
    exp = 2000;
    for (int i = 0; i < inventory_S; i++) {
        inventory[i] = i + 10;
    }

    // Load the data
    EXPECT_EQ(modifData('l', &money, &lvl, &exp, inventory, inventory_S), 0);

    // Check if the loaded data matches the original values
    EXPECT_EQ(money, 100);
    EXPECT_EQ(lvl, 5);
    EXPECT_EQ(exp, 1000);
    for (int i = 0; i < inventory_S; i++) {
        EXPECT_EQ(inventory[i], i + 1);
    }
}

// Test case for resetting data (positive case)
TEST_F(ModifDataTest, ResetDataPositive) {
    // Simulate user input
    std::istringstream input("yes\n");
    std::streambuf* cinbuf = std::cin.rdbuf(input.rdbuf());

    EXPECT_EQ(modifData('r', &money, &lvl, &exp, inventory, inventory_S), 1);

    // Restore the original cin buffer
    std::cin.rdbuf(cinbuf);

    // Check if the data is reset
    EXPECT_EQ(money, 10);
    EXPECT_EQ(lvl, 1);
    EXPECT_EQ(exp, 0);
    EXPECT_EQ(inventory[0], 0);
    for (int i = 1; i < inventory_S; i++) {
        EXPECT_EQ(inventory[i], -1);
    }
}

// Test case for resetting data (negative case)
TEST_F(ModifDataTest, ResetDataNegative) {
    // Simulate user input
    std::istringstream input("no\n");
    std::streambuf* cinbuf = std::cin.rdbuf(input.rdbuf());

    EXPECT_EQ(modifData('r', &money, &lvl, &exp, inventory, inventory_S), 0);

    // Restore the original cin buffer
    std::cin.rdbuf(cinbuf);

    // Check if the data remains unchanged
    EXPECT_EQ(money, 100);
    EXPECT_EQ(lvl, 5);
    EXPECT_EQ(exp, 1000);
    for (int i = 0; i < inventory_S; i++) {
        EXPECT_EQ(inventory[i], i + 1);
    }
}

// Test case for invalid mode
TEST_F(ModifDataTest, InvalidMode) {
    EXPECT_EQ(modifData('x', &money, &lvl, &exp, inventory, inventory_S), 0);
}

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
